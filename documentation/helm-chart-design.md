## Helm Chart Design Guidelines
This document captures the findings from research and the design decisions made by the embedded Pipeline DevSecOps team while developing a standardized approach to creating Helm charts. It serves as a living reference to promote consistent, secure, and maintainable chart development across all efforts supporting the Pipeline team. This document is intended to evolve as new insights and best practices emerge. Minor deviations are an expected part of future designs. However, deviations from this standard approach should be intentional, with justification identified and clearly documented.

# Static Variables
The DevSecOps team defines static variables as values that are not specific to an organization, based on conditional logic, or runtime inputs, acknowledging this usage may differ from terminology in other contexts. Static variables are configuration attributes that remain unchanged for every deployment of a given application or tool such as container image names, ports, or file paths. In the standardized chart design, these variables reside in the chart’s default values file and or values/ directory, or are set in the template files. Static variables are tied to charts rather than any one organizations custom values.

# Dynamic Variables
Dynamic variables refer to configuration values that differ between environments, organizations, or deployments of an application. These values should be passed into Helm charts at deployment time and, as a general rule, should not be stored or defined within the chart itself. However, there are situations where an application must be deployed dynamically across environments such production versus stage. In such cases, dynamic values should be defined within the chart following standardized patterns to ensure consistency during deployment of the application. Dynamic variables can be passed by means of custom values files or at the command line via the set flag during execution.

# Variable Precedence
Charts are expected to leverage Helm's mechanism for overriding values through variable precedence, which enables flexible customization during deployment. Additionally, this allows the team to minimize changes to code. The highest precedence is given to variables passed with the command line set flag, followed by custom values files, and finally, the default values in the chart’s values.yaml file. This allows dynamic values to supersede static definitions when necessary. The Pipeline DevSecOps team recommends using this structure to maintain clarity ensuring static variables remain in values.yaml, while organization or environment specific overrides are passed in as higher precedence inputs during deployments to override any default values as required.

# Directory Structure
Projects may manage multiple Helm charts and may also include other Kubernetes manifests and automation scripts. The directory structure should clearly delineate each component. For example, Charts should be placed in a charts/ subdirectory with one folder per chart, while shared manifests may reside in a manifests/ directory. Scripts for deployment or testing can be grouped under a scripts/ folder. This structure ensures clarity and reusability when scaling deployments across multiple teams.

To support consistency and scalability, the Pipeline DevSecOps team recommends a standardized directory structure for all Helm chart projects. Each application should reside in its own top-level folder containing a charts/ directory for Helm charts, a values/ directory for environment-specific overrides, and optionally a scripts/ or tools/ folder for automation. The root directory of the chart should include documentation files such as README.md and a Chart.yaml if the project is a standalone chart. The subdirectories contained in the templates/ directory may vary between charts. However, the templates directory structure should be created with intention; enhancing the clarity and functionality of the chart.

# Third Party Charts
As part of a standardized approach, the Pipeline DevSecOps team has chosen to store third-party Helm charts directly in version control. This decision was made intentionally to enhance both security and version traceability. By embedding specific versions of third-party charts within the repository, the team ensures full visibility into the code being deployed and eliminates risks associated with uncontrolled updates or upstream changes. Additionally this approach improves auditability, reproducibility of deployments, and will result in tighter integration with  future security review and approval processes. This approach aligns with the team’s goal of minimizing risk and ensuring deterministic predictable deployments.

# Service Validations
Where feasible, Helm charts should include service validations to ensure that deployed resources are functioning correctly post-installation. These validations may take the form of readiness checks, test hooks, or lightweight verification jobs defined within the chart or included as a script. While not always practical during initial development efforts due to complexity or time constraints, the Pipeline DevSecOps team considers this a best practice. Implementations should be prioritized based on the criticality of the service deployment and available development resources. Including validations where possible enhances confidence in deployments and provides early responses in future automated pipelines.

# Documentation
Documentation is a mandatory component of every Helm chart and is considered essential to its completeness and usability. A chart without documentation, regardless of its technical quality, fails to deliver value to the team. At a minimum, each chart must include a README.md file that clearly states the chart’s purpose, prerequisites for deployment, and most importantly, usage instructions. This requirement is absolute and shall not be deviated from for any reason. Proper documentation ensures that charts can be reliably used, understood and maintained by others, and supports long-term operational success.